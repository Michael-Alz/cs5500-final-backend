name: Deploy to EC2 via SSM

on:
    push:
        branches:
            - main # Trigger deployment on push to the main branch

env:
    # Define environment variables used throughout the job
    IMAGE_NAME: ${{ secrets.DOCKER_USERNAME }}/cs5500-backend
    IMAGE_TAG: ${{ github.sha }}

jobs:
    build-and-deploy:
        runs-on: ubuntu-latest
        permissions:
            contents: read # Required to checkout code
        steps:
            - name: Checkout Code
              uses: actions/checkout@v4

            - name: Docker login (Docker Hub)
              uses: docker/login-action@v3
              with:
                  username: ${{ secrets.DOCKER_USERNAME }}
                  password: ${{ secrets.DOCKER_PASSWORD }}

            - name: Build and push image
              uses: docker/build-push-action@v5
              with:
                  context: .
                  file: Dockerfile
                  push: true
                  tags: |
                      ${{ env.IMAGE_NAME }}:latest
                      ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}

            - name: Prepare compose payload (Base64 encode docker-compose)
              id: prepare
              run: |
                  # Encodes the docker-compose file for single-command transmission via SSM
                  echo "compose_b64=$(base64 -w0 docker-compose.prod.yml)" >> "$GITHUB_OUTPUT"

            - name: Configure AWS credentials
              uses: aws-actions/configure-aws-credentials@v2
              with:
                  aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
                  aws-region: ${{ secrets.AWS_REGION }} # Use secret for region

            - name: Deploy via SSM
              env:
                  COMPOSE_B64: ${{ steps.prepare.outputs.compose_b64 }}
                  IMAGE_NAME: ${{ env.IMAGE_NAME }}
                  IMAGE_TAG: ${{ env.IMAGE_TAG }}
                  DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
                  DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
              run: |
                  # The entire deployment script runs on the EC2 instance as root via SSM
                  DEPLOY_SCRIPT=$(cat <<'EOF'
                  set -e # Exit immediately if a command exits with a non-zero status

                  APP_DIR=/home/ec2-user/classconnect
                  IMAGE_NAME="${IMAGE_NAME}"
                  IMAGE_TAG="${IMAGE_TAG}"

                  # 1. Create directory and navigate (Running as root, so 'sudo' is not needed)
                  mkdir -p "$APP_DIR"
                  cd "$APP_DIR"

                  # 2. Decode and write docker-compose file (Directly write as root)
                  echo "$COMPOSE_B64" | base64 -d > docker-compose.prod.yml

                  # 3. Ensure env file exists on the instance
                  if [ ! -f .env.prod ]; then
                    echo ".env.prod is missing in $APP_DIR" >&2
                    exit 1
                  fi

                  # 4. Docker Login (FIXED: Removed 'sudo' to ensure DOCKER_USERNAME is passed)
                  echo "${DOCKER_PASSWORD}" | docker login -u "${DOCKER_USERNAME}" --password-stdin

                  # 5. Pull new image and restart stack (Removed 'sudo' from all docker compose commands)
                  IMAGE_NAME="$IMAGE_NAME" IMAGE_TAG="$IMAGE_TAG" docker compose -f docker-compose.prod.yml pull

                  IMAGE_NAME="$IMAGE_NAME" IMAGE_TAG="$IMAGE_TAG" docker compose -f docker-compose.prod.yml down
                  IMAGE_NAME="$IMAGE_NAME" IMAGE_TAG="$IMAGE_TAG" docker compose -f docker-compose.prod.yml up -d database

                  echo "Waiting for Postgres health..."
                  until docker compose -f docker-compose.prod.yml ps database | grep -q "healthy"; do
                    sleep 5
                  done

                  # Database migrations and seed scripts (Run as root, no 'sudo')
                  IMAGE_NAME="$IMAGE_NAME" IMAGE_TAG="$IMAGE_TAG" docker compose -f docker-compose.prod.yml run --rm backend uv run alembic upgrade head
                  IMAGE_NAME="$IMAGE_NAME" IMAGE_TAG="$IMAGE_TAG" docker compose -f docker-compose.prod.yml run --rm backend uv run python scripts/seed_deploy.py

                  # Start backend service and prune old images
                  IMAGE_NAME="$IMAGE_NAME" IMAGE_TAG="$IMAGE_TAG" docker compose -f docker-compose.prod.yml up -d backend
                  docker image prune -f
                  EOF
                  )
                  # Prepare parameters for the SSM command
                  PARAMS=$(printf '%s' "$DEPLOY_SCRIPT" | jq -Rs '{commands:[.] }')

                  # Send the deployment command
                  COMMAND_ID=$(aws ssm send-command \
                    --instance-ids "${{ secrets.EC2_INSTANCE_ID }}" \
                    --document-name "AWS-RunShellScript" \
                    --comment "Deploy cs5500 backend" \
                    --parameters "$PARAMS" \
                    --query "Command.CommandId" \
                    --output text)

                  echo "SSM command id: $COMMAND_ID"

                  # Wait for command execution and retrieve final output/status
                  aws ssm wait command-executed --command-id "$COMMAND_ID" --instance-id "${{ secrets.EC2_INSTANCE_ID }}"
                  aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "${{ secrets.EC2_INSTANCE_ID }}"
